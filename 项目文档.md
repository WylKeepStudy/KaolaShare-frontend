## 项目技术与工具

```
前端：vue3 + elementplus组件库 + Axios + vueRouter（实现SPA）... （我不太懂 你们自己按自己需要）

后端：springboot + maven + mysql + mybatis + 阿里云OSS	
结构化数据（用户信息表、文件元数据表、学院表）放mysql
非结构化数据（头像、文档）放OSS

部署：前端nginx 后端tomcat（springboot自带） 统一使用docker

API 文档工具：Apifox
代码托管：Github
```



## 项目规范

**命名规范**：

- **变量/方法**：使用小驼峰命名法（`camelCase`），例如 `userProfile`、`saveFile`。
- **类名**：使用大驼峰命名法（`PascalCase`），例如 `UserController`、`FileService`。
- **数据库字段**：使用下划线命名法（`snake_case`），例如 `create_time`。



**后端统一响应格式：**

```
{
  "code": 200,
  "msg": "操作成功",
  "data": {}
}
```

| 字段名 | 数据类型           | 描述                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| `code` | `number`           | **业务状态码**。它表示接口调用的结果。  <br>`200` 表示成功；其他数字（如 `400`、`401`、`404`）表示不同的业务错误。 |
| `msg`  | `string`           | **描述信息**。它提供关于 `code` 的详细说明。  <br>例如，成功时是 `"操作成功"`；失败时是 `"用户名已存在"` 或 `"文件不存在"`。 |
| `data` | `object` 或 `null` | **响应数据**。它包含接口成功时返回的具体业务数据。  <br>如果接口没有数据需要返回（例如注册、登出），这个字段可以为 `null`。 |



**统一工具版本：**

| 分类     | 工具/框架       | 版本             | 备注                                               |
| -------- | --------------- | ---------------- | -------------------------------------------------- |
| **后端** | **JDK**         | **21**           | 作为最新的 **LTS (长期支持) 版本**                 |
|          | **Spring Boot** | **3.5.4**        | 这是 Spring Boot 3.x 系列的最新版本之一            |
|          | **Maven**       | **3.8.x 或更高** | 项目管理和依赖管理工具，确保版本一致性。           |
|          | **MySQL**       | **8.0.x**        | 数据库版本，建议统一，可以通过 Docker 来快速搭建。 |
| **前端** | **Node.js**     | **22.17.1**      | 推荐的长期支持版本，确保前端构建环境一致。         |
|          | **npm**         | **10.9.2**       | Node.js 的包管理器                                 |
|          | **Vue**         | **3.2.38**       | 前端框架。                                         |
|          | **Vite**        | **3.0.9**        | 推荐的前端构建工具，速度快。                       |

x表示任意





## 数据库表



### **1. 用户表 (t_user)**



这张表用于存储所有用户的基本信息。

| 字段名        | 数据类型       | 约束/索引      | 描述                          | 设计考虑                                                     |
| ------------- | -------------- | -------------- | ----------------------------- | ------------------------------------------------------------ |
| `id`          | `BIGINT`       | 主键，自增     | 用户的唯一标识符。            | 使用 `BIGINT` 保证ID的唯一性和足够的容量。                   |
| `username`    | `VARCHAR(50)`  | 唯一索引，非空 | 用户的登录名，要求唯一。      | 唯一索引可以保证用户名不会重复，加快查询速度。               |
| `password`    | `VARCHAR(255)` | 非空           | 用户的加密密码。              | 存储密码的哈希值，而不是明文。`VARCHAR(255)` 足够存储大多数加密算法（如 bcrypt）生成的哈希字符串。 |
| `avatar_url`  | `VARCHAR(255)` | 可空           | 用户头像在阿里云OSS上的地址。 | 可空表示用户可以不设置头像。                                 |
| `create_time` | `DATETIME`     | 非空           | 用户的创建时间。              | 记录用户注册的时间。                                         |



### **2. 系表 (t_department)**



这张表用于存储你提到的“系”的信息，例如“计算机科学系”、“电子工程系”等。这有助于组织和筛选文件。

| 字段名 | 数据类型       | 约束/索引      | 描述                                 | 设计考虑                     |
| ------ | -------------- | -------------- | ------------------------------------ | ---------------------------- |
| `id`   | `BIGINT`       | 主键，自增     | 系的唯一标识符。                     |                              |
| `name` | `VARCHAR(100)` | 唯一索引，非空 | 系的名称，例如“计算机科学与技术系”。 | 唯一索引可以防止重复的系名。 |



### **3. 文件表 (t_file)**



这张表用于存储学习资料的元数据，它将文件和用户、系关联起来。

| 字段名           | 数据类型       | 约束/索引     | 描述                                            | 设计考虑                                 |
| ---------------- | -------------- | ------------- | ----------------------------------------------- | ---------------------------------------- |
| `id`             | `BIGINT`       | 主键，自增    | 文件的唯一标识符。                              |                                          |
| `user_id`        | `BIGINT`       | 外键，非空    | 上传该文件的用户ID，关联 `t_user` 表。          | 建立了文件和上传者之间的关系。           |
| `department_id`  | `BIGINT`       | 外键，非空    | 该文件所属的系/学院ID，关联 `t_department` 表。 | 建立了文件和系之间的关系，方便按系筛选。 |
| `file_name`      | `VARCHAR(255)` | 非空          | 文件的名称。                                    |                                          |
| `file_url`       | `VARCHAR(255)` | 非空          | 文件在阿里云OSS上的存储地址。                   |                                          |
| `file_type`      | `VARCHAR(50)`  | 非空          | 文件的类型，如`pdf`, `doc`, `ppt`。             |                                          |
| `download_count` | `INT`          | 非空，默认`0` | 文件的下载次数。                                | 可以用来排序热门文件。                   |
| `create_time`    | `DATETIME`     | 非空          | 文件的上传时间。                                | 排序                                     |









## 注意



### **关于协议**

**前端**使用https 443端口   前端需要去了解nginx怎么配置https 涉及到ssl/tls证书等等内容 需要自己去了解

此外 学会使用 Apifox 的 Mock 功能，模拟后端接口的返回数据 完成测试 确保功能可用 为后期联调做准备



**后端**使用http 8080端口



---



### 关于密码校验

**注册时**

- 用户在前端输入**明文密码**。
- 通过 **HTTPS** 将明文密码安全地传输到后端。
- 后端接收到明文密码后，使用 **BCrypt** 等强哈希算法对其进行加密（这个过程包含了加盐等步骤）。
- 将生成的**哈希值**存储到数据库中。

**登录时**

- 用户在前端输入**明文密码**。
- 通过 **HTTPS** 将明文密码安全地传输到后端。
- 后端接收到明文密码后，根据用户名从数据库中查询出**之前存储的哈希值**。
- 使用 **BCrypt 的比对函数**（例如 Spring Security 中的 `BCryptPasswordEncoder.matches()` 方法），将用户这次输入的**明文密码**与数据库中存储的**哈希值**进行比对。
- 这个比对函数在内部会完成以下工作：
  - 从数据库的哈希值中提取出“盐值”。
  - 用这个盐值和用户输入的明文密码，再次进行加密。
  - 将新生成的哈希值与数据库中的哈希值进行对比。
- 如果匹配成功，则认证通过；否则，认证失败。



---



### 关于文件下载接口

暂时先只完成单文件下载 前端选一个合适的组件

批量下载后续再说

#### 1. 用户点击下载后会发生什么？



按照你设计的接口 (`GET /file/download/{fileId}`)，用户点击下载按钮后，浏览器会发生以下几个步骤：

1. **前端触发下载**：
   - 前端（Vue3）通过 JavaScript 获取到用户点击的文件的 `id`。
   - 然后，前端会构造一个完整的下载 URL，例如 `http://your-domain.com/api/file/download/101`。
   - 前端通常会创建一个隐藏的 `<a>` 标签，将 `href` 属性设置为这个下载 URL，并模拟点击这个链接，或者直接在浏览器地址栏打开这个 URL。
2. **浏览器处理请求**：
   - 浏览器向后端发送一个 `GET` 请求到 `http://your-domain.com/api/file/download/101`。
   - 在这个请求中，浏览器会带上用户的身份信息（JWT Token）。
3. **后端处理和响应**：
   - 后端接收到请求后，会验证 Token 的有效性，然后从 URL 中解析出 `fileId`（例如 `101`）。
   - 后端根据 `fileId` 查询数据库，获取文件的元数据（包括文件名和 OSS 地址）。
   - 后端从阿里云 OSS 读取文件的二进制流。
   - 后端设置正确的响应头，包括 `Content-Type` 和 `Content-Disposition`，将文件流作为响应返回。
4. **浏览器下载文件**：
   - 浏览器收到后端返回的响应后，会解析 `Content-Disposition` 响应头。
   - 根据这个响应头，浏览器知道这是一个附件，并且有一个指定的文件名。
   - 浏览器会自动弹出一个下载对话框，提示用户保存文件。整个下载过程由浏览器接管，用户体验非常流畅。

**总结**：用户点击下载后，前端的工作非常简单，主要是构造并触发一个带 ID 的 GET 请求。复杂的文件流处理和下载逻辑都在后端完成，浏览器只需要根据后端返回的响应头来处理下载即可。



#### 2. 前端列表展示的文档ID和数据库中的ID不一致如何解决？



这是一个非常好的问题，因为在实际项目中，你说的这种情况经常发生。

**问题根源**：前端展示的序号（1, 2, 3...）是页面上的**临时序号**，与数据库中的`id`（如 `101`, `102`）完全无关。数据库的 `id` 是唯一的、不可变的，而前端的序号是临时的、可变的。

**解决方案**：

在设计**获取文件列表**的接口时，我们应该在返回的 `records` 数组中，**显式地包含数据库中的 `id` 字段**。

我们之前设计的接口响应就是这样做的：

JSON

```
{
  "code": 200,
  "msg": "获取文件列表成功",
  "data": {
    "total": 52,
    "records": [
      {
        "id": 101, // 数据库中的真实ID
        "fileName": "计网期末复习",
        "contributorName": "Baloney",
        "fileType": "pdf"
      },
      // ...
    ]
  }
}
```

- **前端的实现方式**：

  - 前端拿到这个 JSON 响应后，会遍历 `records` 数组，并将其渲染到表格中。
  - **表格中的序号**（1, 2, 3...）可以通过遍历数组时的索引 `index` 加上页码 `pageNum` 来计算得出，这与 `id` 无关。
  - **表格中的下载按钮**：前端在渲染下载按钮时，会把当前行的 `id` (`101` 或 `102`) 绑定到这个按钮上。当用户点击这个按钮时，前端可以轻松地获取到对应的 `id` 值。

- **举例**：

  - 你在 Vue 组件中，可以这样绑定一个点击事件：

    HTML

    ```
    <tr v-for="file in files" :key="file.id">
      <td>{{ file.fileName }}</td>
      <td><button @click="downloadFile(file.id)">下载</button></td>
    </tr>
    ```

  - 这样，当 `downloadFile` 方法被调用时，它会得到正确的数据库 `id`。



---



### 关于JWT

JWT中包含：

**`userId` (用户ID)**：

- **作用**：这是令牌中最重要的信息。后端可以通过它来唯一识别用户，并进行后续的业务操作，比如查询用户信息、记录文件上传者等。

**`username` (用户名)**：

- **作用**：如果需要频繁在日志或某些业务逻辑中使用用户名，可以将其包含在令牌中。这可以减少一次额外的数据库查询，提高效率。

**`exp` (过期时间)**：

- **作用**：这是一个标准的 JWT 声明。它定义了令牌的过期时间，后端可以通过它来判断令牌是否有效，从而防止令牌被长期盗用。



---



### 关于OSS

记得在`application.yml`中把相关配置修改成自己的，用于本地开发和测试

还有数据库的配置信息也记得改成自己的



---



### 关于git使用！！



**如果电脑挂了梯子 访问github网页可以  但是使用git命令时出现网络问题 是因为你的命令行工具没有走代理。**

```
# 配置 HTTP 代理
git config --global http.proxy http://your_proxy_address:port

# 配置 HTTPS 代理
git config --global https.proxy https://your_proxy_address:port

如果你使用的是 shadowsocks 这类代理工具，通常的代理地址是 `127.0.0.1` 加上一个端口号，例如 `1080` 或 `7890`
```



**快速启动指南**：

- `git clone https://github.com/WylKeepStudy/KaolaShare-frontend.git`
- `cd share-front-end`
- `npm install`
- `npm run dev`



#### 1. Git 分支管理

- **主分支**：`main` 分支。
- **功能分支**：为每一个新功能（Feature）创建一个新的分支，命名规范为 `feat-功能描述`，例如 `feat-user-login`。
- **Bug 修复分支**：为每一个 Bug 修复创建一个新的分支，命名规范为 `fix-bug描述`，例如 `fix-file-download-bug`。
- **工作流程**：
  
  1. 从 `main` 分支拉取最新代码：`git pull origin main`
  2. 创建新功能分支：`git checkout -b feat-user-login`
  3. 在新分支上进行开发。
  4. 开发完成后，提交代码到本地仓库：`git commit -m "提交信息"` 提交信息要描述具体，这次提交做了什么
  5. 将本地分支推送到远程仓库：`git push origin feat-user-login`
  6. 在 GitHub 上发起 **Pull Request (PR)**，请求将你的功能分支合并到 `main` 分支。
  
  **首次需要先获取项目：**
  
  ~~~
  git clone https://github.com/WylKeepStudy/KaoLaShare-frontend.git
  cd KaoLaShare-frontend
  ~~~
  
  



注：原则上，main 分支:只用于发布生产环境的代码，受保护，禁止直接提交。所有功能分支应该合并到dev 分支。但是我们项目体量小，就省去dev了。





#### 2. Pull Request (PR) 和 Code Review



- **描述清晰**：在创建 PR 时，请填写清晰的标题和描述，说明你做了什么、解决了什么问题。
- **Code Review**：PR 提交后，团队成员应该互相审查对方的代码。
  - 审查者负责提出改进意见，比如代码风格不一致、潜在的 bug、可优化的地方。
  - 提交者负责根据意见修改代码，并再次提交。
  - 审查通过后，PR 才能被合并到 `main` 分支。







